<!DOCTYPE html>
<html>
    <header>
        <title>ONNX Runtime Web sample</title>
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/water.css@2/out/water.css">
    </header>
    <body>
        <main>
            <h1>Image Classification</h1>

            <canvas id="canvasPreview" style="width: 224px; height: 224px;"></canvas>

            <form id="classifyImageForm">
                <label for="imageInput">Image</label>
                <input id="imageInput" type="file" accept=".png,.jpg,.jpeg">

                <label for="classOutput">Class</label>
                <input id="classOutput" type="text" disabled>

                <input type="submit" value="Classify">
            </form>
        </main>

        <script type="module">
            // import ONNXRuntime Web from CDN
            import * as ort from "https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/esm/ort.min.js"

            // set wasm path override
            ort.env.wasm.wasmPaths = "https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/"

            // create a new session and load the specific model.
            //
            // 1 input:
            //     - 'input_1' (float32, -1x224x224x3)
            // 2 output:
            //     - 'predictions' (float32, -1x1000)
            const session = await ort.InferenceSession.create('./model.onnx')

            // fetch imagenet class index file
            const response = await fetch("imagenet_class_index.json")
            const imagenetClassIndex = await response.json()

            function imageDataToTensor(imageData, dims) {
                // convert image buffer from RGBA to RGB and normalize pixel values between -1 and 1
                const float32Data = new Float32Array(dims[1] * dims[2] * dims[3])
                for (let i = 0, j = 0; i < imageData.length; i += 4, j += 3) {
                    float32Data[j] = (imageData[i] / 127.5) - 1.0
                    float32Data[j + 1] = (imageData[i + 1] / 127.5) - 1.0
                    float32Data[j + 2] = (imageData[i + 2] / 127.5) - 1.0
                }

                // create tensor from RGB buffer with proper dimensions
                const inputTensor = new ort.Tensor("float32", float32Data, dims)
                return inputTensor
            }

            // use an async context to call onnxruntime functions
            async function classifyImage(image) {
                // prepare inputs
                const tensorImage = imageDataToTensor(image, [1, 224, 224, 3])
                const inputs = { input_1: tensorImage }

                try {
                    // feed inputs and run
                    const outputs = await session.run(inputs)

                    // read from outputs
                    const outputPredictions = outputs.predictions.data

                    // compute top predicted class index and name
                    const classIndex = outputPredictions.indexOf(Math.max(...outputPredictions))
                    const className = imagenetClassIndex[String(classIndex)][1]
                    console.info(`class index: ${classIndex}`)
                    console.info(`class name: ${className}`)

                    return className
                } catch (e) {
                    console.error(`failed to inference ONNX model: ${e}.`)
                }
            }

            function main() {
                const imageInput = document.getElementById('imageInput')
                const canvas = document.getElementById("canvasPreview")
                canvas.width = 224
                canvas.height = 224
                const context = canvas.getContext("2d")
                const img = new Image()

                // trigger inference when submiting the form
                const form = document.getElementById('classifyImageForm')
                form.addEventListener('submit', async event => {
                    event.preventDefault()
                    const imageData = context.getImageData(0, 0, canvas.width, canvas.height)
                    const { data, width, height } = imageData
                    const classOutput = await classifyImage(data)
                    document.getElementById('classOutput').value = classOutput
                })

                // preview the selected image in the canvas (which will perform resizing automatically)
                img.addEventListener("load", e => {
                    const scaledHeight = canvas.width * (img.height / img.width)
                    context.reset()
                    context.drawImage(img, 0, (canvas.height - scaledHeight) / 2, canvas.width, scaledHeight)
                })
                imageInput.addEventListener('change', async event => {
                    img.src = window.URL.createObjectURL(event.target.files[0])
                })
            }

            main()
        </script>
    </body>
</html>